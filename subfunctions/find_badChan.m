function [bad_chan_id,exclude,exclude_ts]=find_badChan(eeg,chanNames,fs,thr,twepoch)
%   Find possible pathological channels with HFO and spikes.
%   Pathological (irritative) channels are defined as channels with event 
%   occuerrnce rate > [thr] times of the average HFO+spike rate per
%   channel.
%   Filename: ECoG_XXXX_000X.mat file generated by LBCN_convert_NKnew
%   function.
%   It returns the problematic channel index, indicies of epochs that 
%   overlap with pathological events in each channel (you may want to exclude),
%   and timestamps of the pathological events. 
%   The latest version also returns corrupte epochs (mostly non-neuronal 
%   artifacts, if any) that sould be taken out.
%   -----------------------------------------   
%   =^._.^=   Su Liu 
%
%   suliu@standord.edu
%   -----------------------------------------
% if nargin<1 || isempty(filename)
%     
%     [filename,pathname] = uigetfile({'*.mat','Data format (*.mat)'},'Please select ECoG_XXXX_000X.mat file');
%     filename = fullfile(pathname,filename);
% end

if nargin<4
    thr = 2.5;
end
if nargin < 5 || isempty(twepoch)
    twepoch = [];
end

% load(filename);
% try
%     eeg=D.data.y(:,:,:)';
% catch
%     eeg=D.data(:,:,:)';
% end

bad_chan_id = [];
exclude = [];
exclude_ts = [];
beh_cond = [];
eeg_bi = [];
chan = [];
pcn = [];

%fs=D.Fsample;
z=1;
varall = var(detrend(eeg,'constant'));
thrinit = 8;
bad1 = varall < 0.1*median(varall);
bad2 = varall > thrinit*median(varall);
b2 = fir1(64,[8 70]/(fs/2));
a = 1;
varall2 = var(filtfilt(b2,a,eeg));
bad3 = varall2 > thrinit*median(varall2);
while (isempty(bad2) && thrinit >5)
    thrinit = thrinit - 1;
    bad2 = varall > thrinit*median(varall);
end
%% Create bipolar for HFO and spike detection
fprintf('%s\n','---- Creating bipolar montage ----')
for d=1:size(eeg,2)-1
    
    name1 = join(regexp(string(chanNames{d}),'[a-z]','Match','ignorecase'),'');
    name2 = join(regexp(string(chanNames{d+1}),'[a-z]','Match','ignorecase'),'');
    %chanNames{d}=D.channels(d).label;
    
    if strcmp(name1,name2)
        eeg_bi(:,z)=eeg(:,d)-eeg(:,d+1);
        chan{1,z}=sprintf('%s-%s',chanNames{d},chanNames{d+1});
        z=z+1;
    else
        continue
    end
end
%chanNames{d+1}=D.channels(d+1).label;
%% Detecting events

fprintf('%s\n','---- Detecting pathological events ----');
b = fir1(64,[80 (fs/2)-20]/(fs/2));
a = 1;
input_filtered = filtfilt(b,a,eeg_bi);
n = size(input_filtered,2);
for i = 1:n
    [v(:,i),th] = get_threshold(input_filtered(:,i),round(100*fs/1000),0.5,'std',5);
    try
        timestamp{i}(:,1) = find_event(input_filtered(:,i),th,2,1);
        timestamp{i}(:,2) = i;
    catch
        continue;
    end
end
T = cat(1,timestamp{:});
[~,I] = sort(T(:,1));
event.timestamp = T(I,:);
[alligned,allignedIndex,K] = getaligneddata(eeg_bi,event.timestamp(:,1),[-round(150*fs/1000) round(150*fs/1000)]);
event.timestamp=event.timestamp(logical(K),:);
ttlN = size(alligned,3);
for i = 1:ttlN
    event.data(:,1,i) = alligned(:,event.timestamp(i,2),i);%raw segment
    event.data(:,2,i) = input_filtered(allignedIndex(i,:),...
        event.timestamp(i,2))*1000;%filtered segment
    event.data(:,3,i) = allignedIndex(i,:);%index
end
atf_ind = (eliminate_noise(event.data,fs));
atf_nr = logical(atf_ind{1});
atf_nnr = logical(atf_ind{2});
%event.data(:,:,atf_ind) = [];
channel = event.timestamp(:,2);
channel(logical([atf_nr + atf_nnr]))=[];
pChan = chan(event.timestamp(:,2));
pChan(atf_nr)=[];
event.timestamp(atf_nr,:)=[];
atf_nnr(atf_nr) = [];
s_p = zeros(1,n);
u = unique(channel);
s = zeros(1,length(u));
for j=1:length(u)
    s(j)=length(find(channel==u(j)));
end
s_p(1,u)=s;
%Channels with event occurence rate > 2*median rate are shown. Can change as needed.

pc=chan(s_p>thr*mean(s_p));
pcn = find(s_p>thr*mean(s_p));
try
    nonneural = false(1,length(pc));
    for i = 1:length(pc)
        nonneural(i) = contains(lower(pc{i}),'ekg');
    end
    pc(nonneural)=[];
    pcn(nonneural)=[];
catch
end

while (isempty(pc) && thr >1)
    thr = thr - 0.5;
    pc=chan(s_p>thr*mean(s_p));
    pcn = find(s_p>thr*mean(s_p));
    try
        nonneural = false(1,length(pc));
        for i = 1:length(pc)
            nonneural(i) = contains(lower(pc{i}),'ekg');
        end
        pc(nonneural)=[];
        pcn(nonneural)=[];
    catch
    end 
end
    

monochan=cell(length(pc),2);
for i = 1:length(pc)
    try
        monochan(i,:) = strsplit(pc{i},'-');
    catch
        temp=strsplit(pc{i},'-');
        if length(temp)==4
            monochan(i,1)=strcat(temp(1),'-',temp(2));
            monochan(i,2)=strcat(temp(3),'-',temp(4));
        else
            error('Channel name mismatch');
        end
    end
end

fprintf('---- Done ----')
%%%%%%%%%show problematic chan%%%%%%%%%%%%%%
pathological_chan=unique(monochan(:));
corrupted_chan = chanNames(logical(bad1+bad2+bad3));
corrupted_chan_id = find(logical(bad1+bad2+bad3));
for i=1:length(pathological_chan)
    fc = find(strcmp(pathological_chan{i},chanNames));
    bad_chan_id(i)=fc(1);
end
keep = find((varall(bad_chan_id)./median(varall))>=2);
bad_chan_id = [bad_chan_id(keep) corrupted_chan_id];
pathological_chan = pathological_chan(keep);

disp('Bad channels:');
disp([pathological_chan;corrupted_chan'])

try
    for i=1:length(D.trials.events)
        beh_ts(i)=D.trials.events(i).time*fs;
        beh_cond{i}=D.trials.events(i).type;
    end
    fprintf('%s\n','---- Finding overlapping trials ----')
    [exclude,exclude_ts] = exclude_trial(event.timestamp(:,1),pChan,round(beh_ts),chanNames,twepoch,atf_nnr);
catch
    exclude = [];
    exclude_ts = [];
    beh_cond = [];
end









